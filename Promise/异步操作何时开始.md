
-----

### **学习笔记：Promise 解惑——异步操作何时开始？`new Promise` vs. `.then`**

#### **引言：一个常见的困惑**

在学习 Promise 时，一个最基本也是最常见的困惑是：Promise 中所包含的异步任务（例如一次网络请求），究竟是在 `new Promise()` 的时候就开始执行了，还是等到我们调用 `.then()` 方法时才被触发？

#### **核心结论**

答案非常明确：
**异步操作在 `new Promise()` 时就已经开始执行了，而不是在 `.then()` 时才开始。**

要理解这一点，我们需要清晰地区分 `new Promise()` 和 `.then()` 这两者的角色。



-----

### **时间线证明：用代码看执行顺序**

下面的代码和它的输出顺序，是理解这个概念的最好证明。

```javascript
console.log("1. 脚本开始");

// 2. Promise 构造函数被调用
const myPromise = new Promise((resolve, reject) => {
    // 3. executor 函数被立即、同步地执行！
    console.log("2. Promise executor 开始执行 (异步任务已启动)");

    // 4. 启动一个耗时2秒的异步任务
    setTimeout(() => {
        console.log("5. 异步任务完成！");
        resolve("这是来自服务器的数据"); // 2秒后，Promise 状态变为 fulfilled
    }, 2000);
});

console.log("3. Promise 实例已创建，脚本继续同步执行...");

// 5. 为这个已经“在路上”的 Promise 注册成功后的回调
myPromise.then(data => {
    console.log("6. .then() 的回调被执行，收到了数据:", data);
});

console.log("4. 脚本结束。主线程开始等待异步结果...");
```

#### **控制台输出的时间线**

**立即输出:**

```
1. 脚本开始
2. Promise executor 开始执行 (异步任务已启动)
3. Promise 实例已创建，脚本继续同步执行...
4. 脚本结束。主线程开始等待异步结果...
```

> **分析**：日志 `2` 紧跟在 `1` 后面，并且在 `3` 和 `4` 之前，这无可辩驳地证明了 `new Promise` 内部的 `executor` 函数是在创建时就**立即同步执行**的。

**等待 2 秒后，再输出:**

```
5. 异步任务完成！
6. .then() 的回调被执行，收到了数据: 这是来自服务器的数据
```

> **分析**：`setTimeout` 的回调先执行（日志 `5`），它调用 `resolve()` 改变了 Promise 的状态。紧接着，之前通过 `.then()` 注册的回调函数被触发（日志 `6`）。这证明了 `.then()` 的回调是在异步任务完成后才被执行的。

-----

### **结论与实践建议**

  * **启动**：`new Promise()`
  * **响应**：`.then()`

**一个重要的实践建议**：
要小心在不需要时创建 Promise。因为 `new Promise()` 会立即执行其内容，所以不要在一个循环或者一个会被频繁调用的函数里随意创建 Promise，除非你真的希望每次都发起一个新的异步操作。正确的模式通常是**一次性创建 Promise**，然后可以对这个**同一个 Promise 实例**多次调用 `.then()` 来注册多个不同的后续处理。