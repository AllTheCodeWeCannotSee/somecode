在 JavaScript 中，围绕着对象（特别是通过构造函数或 `class` 创建的“类”）的方法，主要可以分为**三种类型**。它们定义在不同的位置，拥有不同的用途和访问方式。

我们用一个 `Cat`（猫）的构造函数作为例子，来完整地看一下这三种方法的定义和区别。

```javascript
// 1. 构造函数
function Cat(name) {
  this.name = name; // 每个实例自身的属性

  // 2. 实例方法 (Instance Method)
  this.sayName = function() {
    console.log(`我是 ${this.name}，这是我的私有方法。`);
  }
}

// 3. 原型方法 (Prototype Method)
Cat.prototype.meow = function() {
  console.log(`${this.name} 说：喵~ (所有猫共用这个方法)`);
};

// 4. 静态方法 (Static Method)
Cat.getSpecies = function() {
  console.log("猫是猫科动物。(这是一个与具体哪只猫无关的知识)");
};
```

现在，我们来详细解析这三种方法。

-----

### 1\. 实例方法 (Instance Method)

  * **定义位置**：在**构造函数内部**，通过 `this` 关键字直接挂载到新创建的实例上。

  * **核心特点**：

      * **每个实例独有一份**：每执行一次 `new Cat()`，都会在内存中创建一个新的 `sayName` 函数，并赋值给这个新实例。
      * **内存占用高**：如果有 1000 个实例，内存中就有 1000 个独立的 `sayName` 函数，这通常是一种浪费。
      * **可以访问“私有”变量**：如果构造函数内部有通过 `var` 或 `let` 定义的、未挂载到 `this` 上的变量，实例方法可以访问它们（形成闭包）。这是它最主要的应用场景。

  * **调用方式**：必须通过**实例**来调用。

    ```javascript
    const kitty = new Cat('Kitty');
    kitty.sayName(); // 输出: 我是 Kitty，这是我的私有方法。
    ```

-----

### 2\. 原型方法 (Prototype Method)

  * **定义位置**：挂载在**构造函数的 `prototype` 属性**上。

  * **核心特点**：

      * **所有实例共享一份**：无论有多少个实例，内存中只存在一个 `meow` 函数。所有实例都通过原型链（`__proto__`）来找到并使用这个共享的方法。
      * **内存效率极高**：这是在 JavaScript 中为“类”定义方法的**最常用、最推荐**的方式。
      * `this` 指向调用它的实例：当 `kitty.meow()` 被调用时，`meow` 方法内部的 `this` 会正确地指向 `kitty` 实例。

  * **调用方式**：同样是通过**实例**来调用。

    ```javascript
    const tom = new Cat('Tom');
    kitty.meow(); // 输出: Kitty 说：喵~ (所有猫共用这个方法)
    tom.meow();   // 输出: Tom 说：喵~ (所有猫共用这个方法)

    console.log(kitty.meow === tom.meow); // true (证明它们共享的是同一个函数)
    ```

-----

### 3\. 静态方法 (Static Method)

  * **定义位置**：直接作为属性挂载在**构造函数本身**上（把它当作一个普通对象来添加属性）。

  * **核心特点**：

      * **与实例无关**：静态方法不属于任何一个实例，而是属于“类”本身。它通常用来实现一些工具函数或工厂方法。
      * **`this` 指向构造函数**：在静态方法内部，`this` 通常指向 `Cat` 这个构造函数，而不是任何实例。
      * **实例无法访问**：你不能通过一个实例来调用静态方法。

  * **调用方式**：必须通过**构造函数本身**来调用。

    ```javascript
    Cat.getSpecies(); // 输出: 猫是猫科动物。(这是一个与具体哪只猫无关的知识)

    // 尝试用实例调用会报错
    // kitty.getSpecies(); // TypeError: kitty.getSpecies is not a function
    ```

    很多内置对象都有静态方法，例如 `Object.create()`, `Array.isArray()`, `Promise.resolve()`。

### ES6 Class 语法中的对应关系

现代 JavaScript 的 `class` 语法只是上述模式的“语法糖”，其底层原理完全一样，但写法更清晰：

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }

  // 这里的 bark() 就是原型方法
  bark() {
    console.log(`${this.name} 在叫: 汪汪!`);
  }

  // 使用 static 关键字定义静态方法
  static getInfo() {
    console.log("狗是人类的好朋友。");
  }
}

const buddy = new Dog('Buddy');
buddy.bark(); // 调用原型方法

Dog.getInfo(); // 调用静态方法
```

### 总结对比

| 类型 | 定义位置 | 调用方式 | `this` 指向 | 内存占用 | 主要用途 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **实例方法** | 构造函数内部 (`this.`) | `instance.method()` | 当前实例 | **高** (每个实例一份) | 需要访问构造函数闭包中“私有”变量的“特权方法” |
| **原型方法** | 构造函数原型上 (`.prototype.`) | `instance.method()` | 当前实例 | **低** (所有实例共享) | **（标准/推荐）** 定义所有实例通用的核心行为 |
| **静态方法** | 构造函数本身 (`Constructor.`) | `Constructor.method()` | 构造函数本身 | **极低** (只有一份) | 与任何单个实例都无关的工具函数、工厂方法 |